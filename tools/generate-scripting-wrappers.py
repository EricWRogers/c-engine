import re
import os

HEADER_DIR = "src/"
OUTPUT_FILE = "src/scripting/.generated/ScriptBindings.cpp"
EXPORT_MACRO = 'XPLAT_EXPORT'

wrapper_lines = []
wrapper_functions = []
included_headers = set()

pattern = re.compile(r'EXPOSE_TO_SCRIPT\s+static\s+([a-zA-Z0-9_:<>\*&\s]+)\s+(\w+)\(([^)]*)\);')

for root, _, files in os.walk(HEADER_DIR):
    for file in files:
        if not file.endswith(('.h', '.hpp')):
            continue

        full_path = os.path.join(root, file)
        rel_path = os.path.relpath(full_path, start=HEADER_DIR).replace("\\", "/")
        class_name = os.path.splitext(os.path.basename(file))[0]

        with open(full_path, encoding="utf-8") as f:
            content = f.read()
            matches = pattern.findall(content)
            if not matches:
                continue

            included_headers.add(rel_path)

            for ret_type, method_name, args in matches:
                arg_list = [a.strip() for a in args.split(',') if a.strip()]
                arg_names = []
                for arg in arg_list:
                    tokens = arg.strip().replace('*', ' * ').split()
                    if tokens:
                        name = tokens[-1].lstrip('*').replace('&', '').replace('*', '')
                        name = name if name.startswith('_') else '_' + name
                        arg_names.append(name)
                call_args = ', '.join(arg_names)
                wrapper_args = args.strip() or 'void'

                wrapper = f'''
{EXPORT_MACRO} {ret_type.strip()} {class_name}_{method_name}({wrapper_args}) {{
    return {class_name}::{method_name}({call_args});
}}'''
                wrapper_functions.append(wrapper)

# Build final file
wrapper_lines.append('// Auto-generated by generate_wrappers.py')
wrapper_lines.append('#include <cstdint>')
for header in sorted(included_headers):
    wrapper_lines.append(f'#include "{header}"')

wrapper_lines.append(f'''
#ifdef _WIN32
#define {EXPORT_MACRO} __declspec(dllexport)
#else
#define {EXPORT_MACRO}
#endif
''')
wrapper_lines.append('\nextern "C" {')
wrapper_lines.extend(wrapper_functions)
wrapper_lines.append('}\n')

# Write to file
os.makedirs(os.path.dirname(OUTPUT_FILE), exist_ok=True)
with open(OUTPUT_FILE, 'w', encoding='utf-8') as f:
    f.write('\n'.join(wrapper_lines))

print(f'Generated {OUTPUT_FILE} with {len(wrapper_functions)} function(s) and {len(included_headers)} header(s)')
